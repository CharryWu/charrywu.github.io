<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-01-28T09:25:21.217Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>46.permutations</title>
    <link href="http://yoursite.com/2021/01/28/46-permutations/"/>
    <id>http://yoursite.com/2021/01/28/46-permutations/</id>
    <published>2021-01-28T09:18:06.000Z</published>
    <updated>2021-01-28T09:25:21.217Z</updated>
    
    <content type="html"><![CDATA[<p>leetcode 46 全排列 Python 实现</p><a id="more"></a><p>参考<br><a href="https://leetcode-cn.com/problems/permutations/solution/quan-pai-lie-by-leetcode-solution-2/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/permutations/solution/quan-pai-lie-by-leetcode-solution-2/</a><br>这个问题可以看作有 n 个排列成一行的空格，我们需要从左往右依此填入题目给定的 nn 个数，每个数只能使用一次。那么很直接的可以想到一种穷举的算法，即从左往右每一个位置都依此尝试填入一个数，看能不能填完这 n 个空格，在程序中我们可以用「回溯法」来模拟这个过程。</p><p>我们定义递归函数 backtrack(first, output) 表示从左往右填到第 first 个位置，当前排列为 output。 那么整个递归函数分为两个情况：</p><ul><li>如果 first == n，说明我们已经填完了 n 个位置（注意下标从 0 开始），找到了一个可行的解，我们将 output 放入答案数组中，递归结束。</li><li>如果 first &lt; n，我们要考虑这第 first 个位置我们要填哪个数。根据题目要求我们肯定不能填已经填过的数，因此很容易想到的一个处理手段是我们定义一个标记数组 vis[] 来标记已经填过的数，那么在填第 first 个数的时候我们遍历题目给定的 n 个数，如果这个数没有被标记过，我们就尝试填入，并将其标记，继续尝试填下一个位置，即调用函数 backtrack(first + 1, output)。搜索回溯的时候要撤销这一个位置填的数以及标记，并继续尝试其他没被标记过的数。<br>使用标记数组来处理填过的数是一个很直观的思路，但是可不可以去掉这个标记数组呢？毕竟标记数组也增加了我们算法的空间复杂度。</li></ul><p>答案是可以的，我们可以将题目给定的 n 个数的数组 <code>nums[]</code> 划分成左右两个部分，左边的表示已经填过的数，右边表示待填的数，我们在递归搜索的时候只要动态维护这个数组即可。</p><p>具体来说，假设我们已经填到第 first 个位置，那么 nums[] 数组中 [0,first−1] 是已填过的数的集合，[first,n−1] 是待填的数的集合。我们肯定是尝试用 [first,n−1] 里的数去填第 first 个数，假设待填的数的下标为 i ，那么填完以后我们将第 i 个数和第 first 个数交换，即能使得在填第 first+1个数的时候 <code>nums[]</code> 数组的 [0,first] 部分为已填过的数，[first+1,n−1] 为待填的数，回溯的时候交换回来即能完成撤销操作。</p><p>举个简单的例子，假设我们有 [2, 5, 8, 9, 10] 这 5 个数要填入，已经填到第 3 个位置，已经填了 [8,9] 两个数，那么这个数组目前为 [8, 9 | 2, 5, 10] 这样的状态，分隔符区分了左右两个部分。假设这个位置我们要填 10 这个数，为了维护数组，我们将 2 和 10 交换，即能使得数组继续保持分隔符左边的数已经填过，右边的待填 [8, 9, 10 | 2, 5] 。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        res = []</span><br><span class="line">        arr = nums[:]</span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(start)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> start == n:</span><br><span class="line">                res.append(arr[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="comment"># arr[:start] 是已经选取的元素，arr[start:]是尚未被选取的元素</span></span><br><span class="line">            <span class="comment"># 我们的任务就是要从尚未被选取的元素中选一个出来填到 arr[start] 这个位置</span></span><br><span class="line">            <span class="comment"># 注意这样填法填出来的结果不是按照字典顺序的。如果想要按照字典顺序找原数组的排列组合，需要用一个 visited 集合来记录访问过的元素</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(start, n): <span class="comment"># 注意这里必须是 range(start, n) 而不是 range(start+1, n)</span></span><br><span class="line">                arr[start], arr[i] = arr[i], arr[start]</span><br><span class="line">                dfs(start+<span class="number">1</span>) <span class="comment"># 注意这里是 start+1 而不是 i+1</span></span><br><span class="line">                arr[start], arr[i] = arr[i], arr[start]</span><br><span class="line">            </span><br><span class="line">        dfs(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;leetcode 46 全排列 Python 实现&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
      <category term="recursion" scheme="http://yoursite.com/tags/recursion/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
      <category term="backtracking" scheme="http://yoursite.com/tags/backtracking/"/>
    
  </entry>
  
  <entry>
    <title>Python3 bisect_left和 bisect_right 对比</title>
    <link href="http://yoursite.com/2021/01/18/python3-bisect-left-vs-bisect-right/"/>
    <id>http://yoursite.com/2021/01/18/python3-bisect-left-vs-bisect-right/</id>
    <published>2021-01-19T03:49:58.000Z</published>
    <updated>2021-01-19T04:23:33.815Z</updated>
    
    <content type="html"><![CDATA[<p>比较 Python3 <code>bisect</code> 二叉搜索模块中的两个工具方法 <code>bisect_left</code> 和 <code>bisect_right</code></p><a id="more"></a><p>首先上源码:</p><h1 id="bisect-right"><a href="#bisect-right" class="headerlink" title="bisect_right"></a><code>bisect_right</code></h1><p>根据源代码注释，<code>bisect_right</code> 返回的坐标 i 满足条件：<code>all e in a[:i] have e &lt;= x, and all e in a[i:] have e &gt; x.</code><br>例如，<code>bisect_right([1,2,2,2,3,4],2)</code>应返回<code>4</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bisect_right</span><span class="params">(a, x, lo=<span class="number">0</span>, hi=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> lo &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'lo must be non-negative'</span>)</span><br><span class="line">    <span class="keyword">if</span> hi <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        hi = len(a)</span><br><span class="line">    <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">        mid = (lo+hi)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> x &lt; a[mid]: hi = mid</span><br><span class="line">        <span class="keyword">else</span>: lo = mid+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> lo</span><br></pre></td></tr></table></figure><h1 id="bisect-left"><a href="#bisect-left" class="headerlink" title="bisect_left"></a><code>bisect_left</code></h1><p><code>bisect_left</code> 返回的坐标 i 满足条件：<code>all e in a[:i] have e &lt; x, and all e in a[i:] have e &gt;= x.</code><br>例子同上，<code>bisect_left([1,2,2,2,3,4],2)</code>应返回<code>1</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bisect_left</span><span class="params">(a, x, lo=<span class="number">0</span>, hi=None)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> lo &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'lo must be non-negative'</span>)</span><br><span class="line">        <span class="keyword">if</span> hi <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            hi = len(a)</span><br><span class="line">        <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">            mid = (lo+hi)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> a[mid] &lt; x: lo = mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: hi = mid</span><br><span class="line">        <span class="keyword">return</span> lo</span><br></pre></td></tr></table></figure><hr><h1 id="bisect-right和bisect-left区别"><a href="#bisect-right和bisect-left区别" class="headerlink" title="bisect_right和bisect_left区别"></a><code>bisect_right</code>和<code>bisect_left</code>区别</h1><p>我们可以发现，<code>bisect_right</code>和<code>bisect_left</code>只有一处区别：while循环里面当<code>a[mid] == x</code>时，移动的是搜索范围的左侧还是右侧。在每一次while循环中，我们缩小搜索范围到原来的一半。  </p><p>当<code>a[mid] == x</code>时，</p><ul><li><code>bisect_right</code>移动搜索范围的左侧<code>lo</code>到<code>mid</code>的右边，这样搜索范围就会不断往右侧靠拢</li><li><code>bisect_left</code>移动搜索范围的右侧<code>hi</code>到<code>mid</code>，这样搜索范围就会不断往左侧靠拢</li></ul><p>当目标<code>x</code>多次出现在数组中时，上述算法的区别就会导致：<code>bisect_right</code>返回最右边目标<code>x</code>的下一位，而<code>bisect_left</code>返回最左边的目标<code>x</code>的下标</p><h1 id="Note"><a href="#Note" class="headerlink" title="Note:"></a>Note:</h1><p>需要注意的是，当搜索目标在数组中不存在的时候，<code>bisect_left</code>和<code>bisect_right</code>应当返回一样的下标，该下标指向恰好比目标大的数。<br>例如，<br><code>bisect_right([1,3,5,7,9],4)</code>和<code>bisect_left([1,3,5,7,9],4)</code>都返回<code>2</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;比较 Python3 &lt;code&gt;bisect&lt;/code&gt; 二叉搜索模块中的两个工具方法 &lt;code&gt;bisect_left&lt;/code&gt; 和 &lt;code&gt;bisect_right&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
      <category term="recursion" scheme="http://yoursite.com/tags/recursion/"/>
    
      <category term="algo compare" scheme="http://yoursite.com/tags/algo-compare/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="binary-search" scheme="http://yoursite.com/tags/binary-search/"/>
    
  </entry>
  
  <entry>
    <title>根据前序和中序，后序和中序重建二叉树</title>
    <link href="http://yoursite.com/2020/05/10/construct-binary-tree/"/>
    <id>http://yoursite.com/2020/05/10/construct-binary-tree/</id>
    <published>2020-05-11T01:03:35.000Z</published>
    <updated>2021-01-19T03:58:53.681Z</updated>
    
    <content type="html"><![CDATA[<p>本文讨论力扣上根据前序和中序，后序和重建二叉树的两道问题思路与解法；leetcode 105, 106</p><a id="more"></a><p>本文讨论 LeetCode 上两道题：</p><ul><li><a href="https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/" target="_blank" rel="noopener">106. Construct Binary Tree from Inorder and Postorder Traversal</a></li><li><a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">105. Construct Binary Tree from Preorder and Inorder Traversal</a></li></ul><hr><p>如果我们要组建一颗二叉树，就需要采取从顶往下的顺序，只有先建立了父节点才能建立子节点；反而言之，如果要删除一颗二叉树，就要采取从底向上的顺序，只有删除了子节点才能删除父节点。<br>要解这一类问题，我们要先从 pre-order 和 post-order 数组看起，因为 pre-order 和 post-order 才能在 O(1) 的时间内定位到当前子树的父节点(pre-order父节点总是当前数组首元素，post-order节点总是尾元素)。in-order 父节点被夹在左子树和右子树中间，由于我们无法预先得知左子树和右子树的大小，所以我们没办法在 O(1) 时间内定位父节点。</p><p>post-order 数组看起来应该像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[...左子树剩余部分, 左节点, ...右子树剩余部分, 右节点, 根节点]</span><br></pre></td></tr></table></figure><p>其中<code>...左子树剩余部分, 左节点</code>和<code>...右子树剩余部分, 右节点</code>局部与整体结构相似，都是左子树在前，右子树其次，根节点最后，有点像分形 (fractal)。所以 post-order 数组可以进一步扩展成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[...左节点的左子树, 左节点的左节点, ...左节点的右子树, 左节点的右节点, 左节点, ...右节点的左子树, 右节点的左节点, ...右节点的右子树, 右节点的右节点, 右节点, 根节点]</span><br></pre></td></tr></table></figure><p>可以看出，如果我们从后往前遍历这个数组的话，越靠近根节点会越早出现。</p><p>in-order 数组看起来应该像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[左节点左子树..., 左节点, 左节点右子树..., 根节点, 右节点左子树..., 右节点, 右节点右子树...]</span><br></pre></td></tr></table></figure><p>由于我们不知道 左节点左子树… 和 左节点右子树… 相对大小，所以我们不能直接从 in-order 确定哪一个节点才是根节点。</p><p>所以我们要从先从 pre-order 和 post-order 数组看起。post-order 最后一个节点就是根节点。</p><hr><p>本文将会用到 TreeNode 数据结构，定义如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, val=<span class="number">0</span>, left=None, right=None)</span>:</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br></pre></td></tr></table></figure><hr><h2 id="Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal-代码解析"><a href="#Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal-代码解析" class="headerlink" title="Construct Binary Tree from Inorder and Postorder Traversal 代码解析"></a>Construct Binary Tree from Inorder and Postorder Traversal 代码解析</h2><p>算法思想：<br>由于是树，所以不可避免的会用递归算法来解决问题。用递归算法重建一棵树时，我们需要知道它的根节点，与左子树和右子树的内容。</p><p>上文提到，in-order 数组看起来应该像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[左节点左子树..., 左节点, 左节点右子树..., 根节点, 右节点左子树..., 右节点, 右节点右子树...]</span><br></pre></td></tr></table></figure><p>我们只要在 in-order 数组中找到相对应的的父节点的 index，这样我们就能得知左子树大小和右子树大小，以及左子树和右子树中包含什么元素。我们再对左子树和右子树进行递归，就能确定<strong>左节点</strong>和<strong>右节点</strong>的左子树和右子树的大小。直到递归到叶子节点停止，此时当前树的大小为一。</p><p>为了加快在 in-order 查找父节点index的速度，我们在递归前先建立一个 hashmap，存 value -&gt; index 的对应关系，使得之后递归查找的时间复杂度为 O(1)。</p><p>代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(self, inorder, postorder)</span>:</span></span><br><span class="line">        map_inorder = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, val <span class="keyword">in</span> enumerate(inorder): map_inorder[val] = i</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">recur</span><span class="params">(low, high)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> low &gt; high: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            x = TreeNode(postorder.pop())</span><br><span class="line">            mid = map_inorder[x.val]</span><br><span class="line">            x.right = recur(mid+<span class="number">1</span>, high)</span><br><span class="line">            x.left = recur(low, mid<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">        <span class="keyword">return</span> recur(<span class="number">0</span>, len(inorder)<span class="number">-1</span>)</span><br></pre></td></tr></table></figure><p>由于是从尾部pop的，而且右子树比左子树更加靠近尾部，所以先递归右子树，再递归左子树。<br>为了防止重复创建数组带来空间上的 overhead, 代码中的 recur 函数接受的两个参数 low, high 分别<br>为指向 inorder 数组的左指针和右指针。</p><hr><h2 id="Construct-Binary-Tree-from-Inorder-and-Preorder-Traversal-代码解析"><a href="#Construct-Binary-Tree-from-Inorder-and-Preorder-Traversal-代码解析" class="headerlink" title="Construct Binary Tree from Inorder and Preorder Traversal 代码解析"></a>Construct Binary Tree from Inorder and Preorder Traversal 代码解析</h2><p>和 postorder 类似，preorder 只不过是从头部pop的，而且左子树比右子树更加靠近头部，所以先递归左子树，再递归右子树。</p><p>代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(self, preorder: List[int], inorder: List[int])</span> -&gt; TreeNode:</span></span><br><span class="line">        map_inorder = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, val <span class="keyword">in</span> enumerate(inorder): map_inorder[val] = i</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">recur</span><span class="params">(low, high)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> low &gt; high:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            x = TreeNode(preorder.pop(<span class="number">0</span>))</span><br><span class="line">            </span><br><span class="line">            mid = map_inorder[x.val]</span><br><span class="line">            x.left = recur(low, mid<span class="number">-1</span>)</span><br><span class="line">            x.right = recur(mid+<span class="number">1</span>, high)</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">        <span class="keyword">return</span> recur(<span class="number">0</span>, len(inorder)<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文讨论力扣上根据前序和中序，后序和重建二叉树的两道问题思路与解法；leetcode 105, 106&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
      <category term="binary-tree" scheme="http://yoursite.com/tags/binary-tree/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>二叉树层序遍历方法对比 (Python3)</title>
    <link href="http://yoursite.com/2020/05/05/binary-tree-other-traversal-compare/"/>
    <id>http://yoursite.com/2020/05/05/binary-tree-other-traversal-compare/</id>
    <published>2020-05-05T09:13:35.000Z</published>
    <updated>2021-01-19T03:59:04.834Z</updated>
    
    <content type="html"><![CDATA[<p>比较二叉树层序遍历方法包括普通层序 (level order) 和 之字形层序 (zigzag level order) 的实现；leetcode 102, 103, 107</p><a id="more"></a><p>LeetCode 上除了常见的三种 前序、中序、后序遍历题外还有以下层序遍历题目：</p><ul><li><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">层次遍历 (level order)</a></li><li><a href="https://leetcode.com/problems/binary-tree-level-order-traversal-ii/" target="_blank" rel="noopener">自底向上层序遍历</a></li><li><a href="https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/" target="_blank" rel="noopener">之字形层序遍历 (zigzag level order)</a></li></ul><hr><p>本文将会用到 TreeNode 数据结构，定义如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, val=<span class="number">0</span>, left=None, right=None)</span>:</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br></pre></td></tr></table></figure><hr><h1 id="层序遍历-Pre-order"><a href="#层序遍历-Pre-order" class="headerlink" title="层序遍历 (Pre-order)"></a>层序遍历 (Pre-order)</h1><p>层序遍历的核心思想是，每一个循环里我们只遍历当前这层，并且把下一层非空的节点添加到待循环列表里面。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root <span class="keyword">or</span> root.val == <span class="literal">None</span>: <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        all = []</span><br><span class="line">        thislevel = [root]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> thislevel: <span class="comment"># thislevel is the best</span></span><br><span class="line">            nextlevel = [] <span class="comment"># separate from thislevel because we want to populate nextlevel based on thislevel in the loop</span></span><br><span class="line">            all.append(list(map(<span class="keyword">lambda</span> n: n.val,thislevel)))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> n <span class="keyword">in</span> thislevel:</span><br><span class="line">                <span class="keyword">if</span> n.left:</span><br><span class="line">                    nextlevel.append(n.left)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> n.right:</span><br><span class="line">                    nextlevel.append(n.right)</span><br><span class="line"></span><br><span class="line">            thislevel = nextlevel</span><br><span class="line">        <span class="keyword">return</span> all</span><br></pre></td></tr></table></figure><hr><h1 id="自底向上层序遍历-Bottom-up-level-order"><a href="#自底向上层序遍历-Bottom-up-level-order" class="headerlink" title="自底向上层序遍历 (Bottom-up level order)"></a>自底向上层序遍历 (Bottom-up level order)</h1><p>和普通层序遍历代码几乎一模一样，唯一的区别就是仅仅需要将结果翻转，底层的内容放到前面来</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrderBottom</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root <span class="keyword">or</span> root.val == <span class="literal">None</span>: <span class="keyword">return</span> [] <span class="comment"># empty tree case</span></span><br><span class="line"></span><br><span class="line">        all = []</span><br><span class="line">        thislevel = [root]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> thislevel:</span><br><span class="line">            nextlevel = []</span><br><span class="line">            all.append(list(map(<span class="keyword">lambda</span> n: n.val,thislevel)))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> n <span class="keyword">in</span> thislevel:</span><br><span class="line">                <span class="keyword">if</span> n.left:</span><br><span class="line">                    nextlevel.append(n.left)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> n.right:</span><br><span class="line">                    nextlevel.append(n.right)</span><br><span class="line"></span><br><span class="line">            thislevel = nextlevel</span><br><span class="line">        <span class="keyword">return</span> all[::<span class="number">-1</span>] <span class="comment"># 结果翻转</span></span><br></pre></td></tr></table></figure><hr><p>之字形遍历代码结构大体上和层序遍历一样，但是为了使得每一层方向不一样，我们使用一个<code>counter</code>变量，来指挥每一层是向左还是向右，偶数层向右，技术层向左。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">zigzagLevelOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root <span class="keyword">or</span> root.val == <span class="literal">None</span>: <span class="keyword">return</span> [] <span class="comment"># empty tree case</span></span><br><span class="line"></span><br><span class="line">        all = []</span><br><span class="line">        thislevel = [root]</span><br><span class="line">        counter = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> thislevel: <span class="comment"># thislevel is the best</span></span><br><span class="line">            nextlevel = [] <span class="comment"># separate from thislevel because we want to populate nextlevel based on thislevel in the loop</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># invert on odd-numbered rows</span></span><br><span class="line">            <span class="keyword">if</span> counter % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                all.append(list(map(<span class="keyword">lambda</span> n: n.val,thislevel)))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                all.append(list(map(<span class="keyword">lambda</span> n: n.val,thislevel[::<span class="number">-1</span>])))</span><br><span class="line"></span><br><span class="line">            counter += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> n <span class="keyword">in</span> thislevel:</span><br><span class="line">                <span class="keyword">if</span> n.left:</span><br><span class="line">                    nextlevel.append(n.left)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> n.right:</span><br><span class="line">                    nextlevel.append(n.right)</span><br><span class="line"></span><br><span class="line">                thislevel = nextlevel</span><br><span class="line">        <span class="keyword">return</span> all</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;比较二叉树层序遍历方法包括普通层序 (level order) 和 之字形层序 (zigzag level order) 的实现；leetcode 102, 103, 107&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
      <category term="binary-tree" scheme="http://yoursite.com/tags/binary-tree/"/>
    
      <category term="recursion" scheme="http://yoursite.com/tags/recursion/"/>
    
      <category term="algo compare" scheme="http://yoursite.com/tags/algo-compare/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>二叉树遍历的 Recursive/Iterative 方法对比 (Python3)</title>
    <link href="http://yoursite.com/2020/05/04/binary-tree-traversal-recursive-iterative-compare/"/>
    <id>http://yoursite.com/2020/05/04/binary-tree-traversal-recursive-iterative-compare/</id>
    <published>2020-05-05T06:04:45.000Z</published>
    <updated>2021-01-19T04:01:25.974Z</updated>
    
    <content type="html"><![CDATA[<p>二叉树的前序、中序、后序遍历的 Iterative 和 Recursive 实现对比；leetcode 94, 144, 145；阅读时间: 15-20 min</p><a id="more"></a><p>二叉树常见的遍历 (Traversal) 方法有三种：</p><ul><li><a href="https://leetcode.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">144. Binary Tree Preorder Traversal</a></li><li><a href="https://leetcode.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">94. Binary Tree Inorder Traversal</a></li><li><a href="https://leetcode.com/problems/binary-tree-postorder-traversal/" target="_blank" rel="noopener">145. Binary Tree Postorder Traversal</a></li></ul><p>从实现层面来说，有两种 Implementation: </p><ul><li>Recursive</li><li>Iterative</li></ul><p>两种方法都需要用到 stack。由于 Recursive 方法 implicitly 调用了 function call stack，实现代码相对简单；而 Iterative 方法实现相对复杂，需要 explicitly 声明一个 stack variable 并手动管理。</p><hr><p>本文将会用到 TreeNode 数据结构，定义如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, val=<span class="number">0</span>, left=None, right=None)</span>:</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br></pre></td></tr></table></figure><p>所有遍历方式时间复杂度都是 O(n), 空间复杂度是 O(h)，n=节点总数，h=树的高度<br>O(logn) &lt;= O(h) &lt;= O(n)</p><hr><h1 id="前序遍历-Pre-order"><a href="#前序遍历-Pre-order" class="headerlink" title="前序遍历 (Pre-order)"></a>前序遍历 (Pre-order)</h1><p><strong>Recursive:</strong><br>在三种方法中，最简单的就是 pre-order 的实现，顺序是 <code>parent -&gt; left -&gt; right</code>。和其他两种遍历相比，parent node 不需要被压入栈中，可以立即被访问。待访问的是其左右子节点，所以只有左右非空子节点会被压入栈中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        res = [] <span class="comment"># 需要返回的 result, list of node.val</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">recur</span><span class="params">(node)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            res.append(node.val)</span><br><span class="line">            recur(node.left)</span><br><span class="line">            recur(node.right)</span><br><span class="line"></span><br><span class="line">        recur(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><strong>Iterative:</strong><br>要把 Recursion 转为 Iteration，我们就需要用一个 <code>stack</code> 变量来装所有待访问的节点。一旦我们从 <code>stack</code> 中 pop 出来一个 TreeNode，我们立即对其访问，将其放入 <code>res</code> 里面。栈顶的 TreeNode 更加靠近树的底层，栈底 TreeNode 靠近树的上层。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        pre-order: parent -&gt; left -&gt; right</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        stack = [root] <span class="comment"># List of TreeNode</span></span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            top = stack.pop() <span class="comment"># pop from end</span></span><br><span class="line">            res.append(top.val)</span><br><span class="line">            <span class="comment"># 注意我们先 push right child，再 push left child</span></span><br><span class="line">            <span class="comment"># left child 更加靠近栈顶，会比 right child 更早地被 pop 出来</span></span><br><span class="line">            <span class="comment"># preorder 顺序是 parent -&gt; left -&gt; right</span></span><br><span class="line">            <span class="keyword">if</span> top.right:</span><br><span class="line">                stack.append(top.right)</span><br><span class="line">            <span class="keyword">if</span> top.left:</span><br><span class="line">                stack.append(top.left)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><div class="tip">在上面代码中，注意 right child 先于 left child 压入栈中。这么做是因为 preorder 顺序是 parent -> left -> right，后压入的 left child 更加靠近栈顶，会比 right child 更早地被 pop 出来</div><hr><h1 id="中序遍历-In-order"><a href="#中序遍历-In-order" class="headerlink" title="中序遍历 (In-order)"></a>中序遍历 (In-order)</h1><p><strong>Recursive:</strong><br>中序遍历顺序是 <code>left -&gt; parent -&gt; right</code>，在访问 parent 之前需要确保其整个左子树中的元素都已经被访问。In-order recursive 代码和其他两种遍历方法几乎一样，只是访问 node.val 的顺序不一样。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        res = [] <span class="comment"># 需要返回的 result, list of node.val</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">recur</span><span class="params">(node)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            recur(node.left)</span><br><span class="line">            res.append(node.val)</span><br><span class="line">            recur(node.right)</span><br><span class="line"></span><br><span class="line">        recur(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><strong>Iterative:</strong><br>In-order 的 Iterative 方法就没有 Pre-order 那么直接易懂了。我们需要借助一个新的 TreeNode 指针 <code>current</code> 来引导，尽可能地将所有左节点都先 push 到 stack 里面，确保任何 node 在被访问之前，它的左节点都已压入栈中。这么做目的在于，访问任一节点前都能确保其左节点已经被检查过了：要么 <code>left</code> 为空，要么 <code>left</code> 已被访问 (被 append 到 <code>res</code> 里面)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        in-order: left -&gt; parent -&gt; right</span></span><br><span class="line"><span class="string">        要确保在访问 parent 前已经访问了left</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        stack = []</span><br><span class="line">        current = root</span><br><span class="line">        <span class="keyword">while</span> current <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">while</span> current:</span><br><span class="line">                stack.append(current)</span><br><span class="line">                current = current.left</span><br><span class="line"></span><br><span class="line">            current = stack.pop()</span><br><span class="line">            res.append(current.val)</span><br><span class="line">            current = current.right</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><strong>Walkthrough:</strong><br>进入 inner while loop，current一直向左走并将所有左节点压入栈中，直到遇到 leaf node，代码会先检查它的左节点(空)，跳出 inner while loop，然后将 leaf 从 <code>stack</code> 中 pop 出来，再检查 leaf 的右节点(空)。然后在下一个循环开始，由于右节点为空，<code>current == None</code>，但是 stack 中依然有 leaf 的 parent，所以 <code>stack</code> 不为空，进入下一个循环访问 leaf parent  </p><p>如果 leaf parent 有右子树的话，current 会指向 parent 右节点，但不会立即访问，而是将其压入栈中，然后重复上面步骤，往右节点左边一直走</p><hr><h1 id="后序遍历-Post-order"><a href="#后序遍历-Post-order" class="headerlink" title="后序遍历 (Post-order)"></a>后序遍历 (Post-order)</h1><p><strong>Recursive:</strong><br>后序遍历顺序是 <code>left -&gt; right -&gt; parent</code>，大体上是 Pre-order 反过来，但不是严格的 Pre-order 反过来的情况： <code>right -&gt; left -&gt; parent</code>。Recursive 方法代码和其它两种方法几乎一样，只是顺序不同。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        res = [] <span class="comment"># 需要返回的 result, list of node.val</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">recur</span><span class="params">(node)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            recur(node.left)</span><br><span class="line">            recur(node.right)</span><br><span class="line">            res.append(node.val)</span><br><span class="line"></span><br><span class="line">        recur(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><strong>Iterative:</strong><br>Post-order 和 Pre-order 的 Iterative 方法的代码非常类似，只是有两个区别：先将左节点压入栈，再将右节点压入栈，这样<br>就会先pop右节点而不是左节点，在 while loop 结束后，<code>res</code> 中顺序是 <code>parent -&gt; right -&gt; left</code>，<br>然后我们将 <code>res</code> 反转一下就得到 <code>left -&gt; right -&gt; parent</code> 顺序了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        post-order: left -&gt; right -&gt; parent</span></span><br><span class="line"><span class="string">        和 Pre-order 的 Iterative 方法的代码非常类似，最后将 res 倒置就行了</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        stack, res = [root], []</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            top = stack.pop()</span><br><span class="line">            res.append(top.val)</span><br><span class="line">            <span class="comment"># 和 pre-order 不一样，这里先将压入左节点，再压右节点</span></span><br><span class="line">            <span class="keyword">if</span> top.left:</span><br><span class="line">                stack.append(top.left)</span><br><span class="line">            <span class="keyword">if</span> top.right:</span><br><span class="line">                stack.append(top.right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;二叉树的前序、中序、后序遍历的 Iterative 和 Recursive 实现对比；leetcode 94, 144, 145；阅读时间: 15-20 min&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
      <category term="binary-tree" scheme="http://yoursite.com/tags/binary-tree/"/>
    
      <category term="recursion" scheme="http://yoursite.com/tags/recursion/"/>
    
      <category term="algo compare" scheme="http://yoursite.com/tags/algo-compare/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2020/02/23/hello-world/"/>
    <id>http://yoursite.com/2020/02/23/hello-world/</id>
    <published>2020-02-23T13:06:44.613Z</published>
    <updated>2020-02-23T13:06:44.613Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
