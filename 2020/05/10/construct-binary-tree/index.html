<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 根据前序和中序，后序和中序重建二叉树 · Hexo</title><meta name="description" content="根据前序和中序，后序和中序重建二叉树 - John Doe"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="Hexo"><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/CharryWu" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="https://leetcode.com/charrywu/" target="_blank" class="nav-list-link">LEETCODE</a></li><li class="nav-list-item"><a href="https://www.linkedin.com/in/charrywu/" target="_blank" class="nav-list-link">LINKEDIN</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">根据前序和中序，后序和中序重建二叉树</h1><div class="post-info">May 10, 2020</div><div class="post-content"><p>本文讨论 LeetCode 上两道题：</p>
<ul>
<li><a href="https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/" target="_blank" rel="noopener">106. Construct Binary Tree from Inorder and Postorder Traversal</a></li>
<li><a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">105. Construct Binary Tree from Preorder and Inorder Traversal</a></li>
</ul>
<hr>
<p>如果我们要组建一颗二叉树，就需要采取从顶往下的顺序，只有先建立了父节点才能建立子节点；反而言之，如果要删除一颗二叉树，就要采取从底向上的顺序，只有删除了子节点才能删除父节点。<br>要解这一类问题，我们要先从 pre-order 和 post-order 数组看起，因为 pre-order 和 post-order 才能在 O(1) 的时间内定位到当前子树的父节点(pre-order父节点总是当前数组首元素，post-order节点总是尾元素)。in-order 父节点被夹在左子树和右子树中间，由于我们无法预先得知左子树和右子树的大小，所以我们没办法在 O(1) 时间内定位父节点。</p>
<p>post-order 数组看起来应该像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[...左子树剩余部分, 左节点, ...右子树剩余部分, 右节点, 根节点]</span><br></pre></td></tr></table></figure>
<p>其中<code>...左子树剩余部分, 左节点</code>和<code>...右子树剩余部分, 右节点</code>局部与整体结构相似，都是左子树在前，右子树其次，根节点最后，有点像分形 (fractal)。所以 post-order 数组可以进一步扩展成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[...左节点的左子树, 左节点的左节点, ...左节点的右子树, 左节点的右节点, 左节点, ...右节点的左子树, 右节点的左节点, ...右节点的右子树, 右节点的右节点, 右节点, 根节点]</span><br></pre></td></tr></table></figure>
<p>可以看出，如果我们从后往前遍历这个数组的话，越靠近根节点会越早出现。</p>
<p>in-order 数组看起来应该像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[左节点左子树..., 左节点, 左节点右子树..., 根节点, 右节点左子树..., 右节点, 右节点右子树...]</span><br></pre></td></tr></table></figure>

<p>由于我们不知道 左节点左子树… 和 左节点右子树… 相对大小，所以我们不能直接从 in-order 确定哪一个节点才是根节点。</p>
<p>所以我们要从先从 pre-order 和 post-order 数组看起。post-order 最后一个节点就是根节点。</p>
<hr>
<p>本文将会用到 TreeNode 数据结构，定义如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, val=<span class="number">0</span>, left=None, right=None)</span>:</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal-代码解析"><a href="#Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal-代码解析" class="headerlink" title="Construct Binary Tree from Inorder and Postorder Traversal 代码解析"></a>Construct Binary Tree from Inorder and Postorder Traversal 代码解析</h2><p>算法思想：<br>由于是树，所以不可避免的会用递归算法来解决问题。用递归算法重建一棵树时，我们需要知道它的根节点，与左子树和右子树的内容。</p>
<p>上文提到，in-order 数组看起来应该像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[左节点左子树..., 左节点, 左节点右子树..., 根节点, 右节点左子树..., 右节点, 右节点右子树...]</span><br></pre></td></tr></table></figure>

<p>我们只要在 in-order 数组中找到相对应的的父节点的 index，这样我们就能得知左子树大小和右子树大小，以及左子树和右子树中包含什么元素。我们再对左子树和右子树进行递归，就能确定<strong>左节点</strong>和<strong>右节点</strong>的左子树和右子树的大小。直到递归到叶子节点停止，此时当前树的大小为一。</p>
<p>为了加快在 in-order 查找父节点index的速度，我们在递归前先建立一个 hashmap，存 value -&gt; index 的对应关系，使得之后递归查找的时间复杂度为 O(1)。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(self, inorder, postorder)</span>:</span></span><br><span class="line">        map_inorder = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, val <span class="keyword">in</span> enumerate(inorder): map_inorder[val] = i</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">recur</span><span class="params">(low, high)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> low &gt; high: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            x = TreeNode(postorder.pop())</span><br><span class="line">            mid = map_inorder[x.val]</span><br><span class="line">            x.right = recur(mid+<span class="number">1</span>, high)</span><br><span class="line">            x.left = recur(low, mid<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">        <span class="keyword">return</span> recur(<span class="number">0</span>, len(inorder)<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>
<p>由于是从尾部pop的，而且右子树比左子树更加靠近尾部，所以先递归右子树，再递归左子树。<br>为了防止重复创建数组带来空间上的 overhead, 代码中的 recur 函数接受的两个参数 low, high 分别<br>为指向 inorder 数组的左指针和右指针。</p>
<hr>
<h2 id="Construct-Binary-Tree-from-Inorder-and-Preorder-Traversal-代码解析"><a href="#Construct-Binary-Tree-from-Inorder-and-Preorder-Traversal-代码解析" class="headerlink" title="Construct Binary Tree from Inorder and Preorder Traversal 代码解析"></a>Construct Binary Tree from Inorder and Preorder Traversal 代码解析</h2><p>和 postorder 类似，preorder 只不过是从头部pop的，而且左子树比右子树更加靠近头部，所以先递归左子树，再递归右子树。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(self, preorder: List[int], inorder: List[int])</span> -&gt; TreeNode:</span></span><br><span class="line">        map_inorder = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, val <span class="keyword">in</span> enumerate(inorder): map_inorder[val] = i</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">recur</span><span class="params">(low, high)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> low &gt; high:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            x = TreeNode(preorder.pop(<span class="number">0</span>))</span><br><span class="line">            </span><br><span class="line">            mid = map_inorder[x.val]</span><br><span class="line">            x.left = recur(low, mid<span class="number">-1</span>)</span><br><span class="line">            x.right = recur(mid+<span class="number">1</span>, high)</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">        <span class="keyword">return</span> recur(<span class="number">0</span>, len(inorder)<span class="number">-1</span>)</span><br></pre></td></tr></table></figure></div></article></div></main><footer><div class="paginator"><a href="/2020/05/05/binary-tree-other-traversal-compare/" class="next">NEXT</a></div><div class="copyright"><p>© 2020 <a href="http://yoursite.com">John Doe</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-148509301-1",'auto');ga('send','pageview');</script></body></html>