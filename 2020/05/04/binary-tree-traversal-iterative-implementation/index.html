<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 二叉树的 Iterative Traversal 实现 (Python3) · Hexo</title><meta name="description" content="二叉树的 Iterative Traversal 实现 (Python3) - John Doe"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="Hexo"><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/CharryWu" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="https://leetcode.com/charrywu/" target="_blank" class="nav-list-link">LEETCODE</a></li><li class="nav-list-item"><a href="https://www.linkedin.com/in/charrywu/" target="_blank" class="nav-list-link">LINKEDIN</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">二叉树的 Iterative Traversal 实现 (Python3)</h1><div class="post-info">May 4, 2020</div><div class="post-content"><p>二叉树有三种遍历 (Traversal) 的方法：</p>
<ul>
<li>前序遍历 (Pre-order)</li>
<li>中序遍历 (In-order)</li>
<li>后序遍历 (Post-order)。</li>
</ul>
<p>从实现层面来说，有两种 Implementation: </p>
<ul>
<li>Recursive</li>
<li>Iterative</li>
</ul>
<p>两种方法都需要用到 stack。由于 Recursive 方法 implicitly 调用了 function call stack，实现代码相对简单；而 Iterative 方法实现相对复杂，需要 explicitly 声明一个 stack variable 并手动管理。</p>
<p>本文将会对比三种遍历方法的 Iterative 和 Recursive 的 Python3 实现。</p>
<hr>
<p>本文中将会用到以下数据结构：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, val=<span class="number">0</span>, left=None, right=None)</span>:</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br></pre></td></tr></table></figure>
<p>所有遍历方式时间复杂度都是 O(n), 空间复杂度是 O(h)，n=节点总数，h=树的高度<br>O(logn) &lt;= O(h) &lt;= O(n)</p>
<hr>
<h1 id="前序遍历-Pre-order"><a href="#前序遍历-Pre-order" class="headerlink" title="前序遍历 (Pre-order)"></a>前序遍历 (Pre-order)</h1><p><strong>Recursive:</strong><br>在三种方法中，最简单的就是 Pre-order 的实现，顺序是 <code>parent -&gt; left -&gt; right</code>。和其他两种遍历相比，parent node 不需要被压入栈中，可以立即被访问。待访问的是其左右子节点，所以只有左右非空子节点会被压入栈中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        res = [] <span class="comment"># 需要返回的 result, list of node.val</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">recur</span><span class="params">(node)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            res.append(node.val)</span><br><span class="line">            recur(node.left)</span><br><span class="line">            recur(node.right)</span><br><span class="line"></span><br><span class="line">        recur(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p><strong>Iterative:</strong><br>要把 Recursion 转为 Iteration，我们就需要用一个 <code>stack</code> 变量来装所有待访问的节点。一旦我们从 <code>stack</code> 中 pop 出来一个 TreeNode，我们立即对其访问，将其放入 <code>res</code> 里面。栈顶的 TreeNode 更加靠近树的底层，栈底 TreeNode 靠近树的上层。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        pre-order: parent -&gt; left -&gt; right</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        stack = [root] <span class="comment"># List of TreeNode</span></span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            top = stack.pop() <span class="comment"># pop from end</span></span><br><span class="line">            res.append(top.val)</span><br><span class="line">            <span class="comment"># 注意我们是先 push right child，再 push left child</span></span><br><span class="line">            <span class="comment"># left child 更加靠近栈顶，会比 right child 更早地被 pop 出来</span></span><br><span class="line">            <span class="comment"># preorder 顺序是 parent -&gt; left -&gt; right</span></span><br><span class="line">            <span class="keyword">if</span> top.right:</span><br><span class="line">                stack.append(top.right)</span><br><span class="line">            <span class="keyword">if</span> top.left:</span><br><span class="line">                stack.append(top.left)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="中序遍历-In-order"><a href="#中序遍历-In-order" class="headerlink" title="中序遍历 (In-order)"></a>中序遍历 (In-order)</h1><p><strong>Recursive:</strong><br>中序遍历顺序是 <code>left -&gt; parent -&gt; right</code>，在访问 parent 之前需要确保其整个左子树中的元素都已经被访问。In-order recursive 代码和其他两种遍历方法几乎一样，只是访问 node.val 的顺序不一样。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        res = [] <span class="comment"># 需要返回的 result, list of node.val</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">recur</span><span class="params">(node)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            recur(node.left)</span><br><span class="line">            res.append(node.val)</span><br><span class="line">            recur(node.right)</span><br><span class="line"></span><br><span class="line">        recur(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p><strong>Iterative:</strong><br>In-order 的 Iterative 方法就没有 Pre-order 那么直接易懂了。我们需要借助一个新的 TreeNode 指针 <code>current</code> 来引导，尽可能地将所有左节点都先 push 到 stack 里面，确保任何 node 在被访问之前，它的左节点都已压入栈中。这么做目的在于，访问任一节点前都能确保其左节点已经被检查过了：要么 <code>left</code> 为空，要么 <code>left</code> 已被访问 (被 append 到 <code>res</code> 里面)。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        in-order: left -&gt; parent -&gt; right</span></span><br><span class="line"><span class="string">        要确保在访问 parent 前已经访问了left</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        stack = []</span><br><span class="line">        current = root</span><br><span class="line">        <span class="keyword">while</span> current <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">while</span> current:</span><br><span class="line">                stack.append(current)</span><br><span class="line">                current = current.left</span><br><span class="line"></span><br><span class="line">            current = stack.pop()</span><br><span class="line">            res.append(current.val)</span><br><span class="line">            current = current.right</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p><strong>Walkthrough:</strong><br>进入 inner while loop，current一直向左走并将所有左节点压入栈中，直到遇到 leaf node，代码会先检查它的左节点(空)，跳出 inner while loop，然后将 leaf 从 <code>stack</code> 中 pop 出来，再检查 leaf 的右节点(空)。然后在下一个循环开始，由于右节点为空，<code>current == None</code>，但是 stack 中依然有 leaf 的 parent，所以 <code>stack</code> 不为空，进入下一个循环访问 leaf parent  </p>
<p>如果 leaf parent 有右子树的话，current 会指向 parent 右节点，但不会立即访问，而是将其压入栈中，然后重复上面步骤，往右节点左边一直走</p>
<hr>
<h1 id="后序遍历-Post-order"><a href="#后序遍历-Post-order" class="headerlink" title="后序遍历 (Post-order)"></a>后序遍历 (Post-order)</h1><p><strong>Recursive:</strong><br>后序遍历顺序是 <code>left -&gt; right -&gt; parent</code>，大体上是 Pre-order 反过来，但不是严格的 Pre-order 反过来的情况： <code>right -&gt; left -&gt; parent</code>。Recursive 方法代码和其它两种方法几乎一样，只是顺序不同。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        res = [] <span class="comment"># 需要返回的 result, list of node.val</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">recur</span><span class="params">(node)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            recur(node.left)</span><br><span class="line">            recur(node.right)</span><br><span class="line">            res.append(node.val)</span><br><span class="line"></span><br><span class="line">        recur(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p><strong>Iterative:</strong><br>Post-order 和 Pre-order 的 Iterative 方法的代码非常类似，只是有两个区别：先将左节点压入栈，再将右节点压入栈，这样<br>就会先pop右节点而不是左节点，在 while loop 结束后，<code>res</code> 中顺序是 <code>parent -&gt; right -&gt; left</code>，<br>然后我们将 <code>res</code> 反转一下就得到 <code>left -&gt; right -&gt; parent</code> 顺序了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        post-order: left -&gt; right -&gt; parent</span></span><br><span class="line"><span class="string">        和 Pre-order 的 Iterative 方法的代码非常类似，最后将 res 倒置就行了</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        stack, res = [root], []</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            top = stack.pop()</span><br><span class="line">            res.append(top.val)</span><br><span class="line">            <span class="comment"># 和 pre-order 不一样，这里先将压入左节点，再压右节点</span></span><br><span class="line">            <span class="keyword">if</span> top.left:</span><br><span class="line">                stack.append(top.left)</span><br><span class="line">            <span class="keyword">if</span> top.right:</span><br><span class="line">                stack.append(top.right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
</div></article></div></main><footer><div class="paginator"><a href="/2020/02/23/hello-world/" class="next">NEXT</a></div><div class="copyright"><p>© 2020 <a href="http://yoursite.com">John Doe</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-148509301-1",'auto');ga('send','pageview');</script></body></html>